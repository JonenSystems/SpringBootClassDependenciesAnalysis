<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>解析機能要求一覧</title>
<style>
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP","Hiragino Kaku Gothic ProN","Meiryo",sans-serif;margin-left: 300px;line-height:1.6;}
h2,h3{margin:1.2em 0 0.4em; text-align:center;}

table{border-collapse:collapse;margin:1em 0;width:100%;table-layout:auto;}
th,td{border:1px solid #000;padding:8px;vertical-align:top;}

.note{color:#666;font-size:0.9em}
.upper_request{background:#FFF2CC;}
.lower_request{background:#D9E1F2;}
</style>

<style>
.sidebar-nav {
  position: fixed;
  top: 0;
  left: 0;
  width: 280px;
  height: 100vh;
  padding: 24px 20px;
  box-sizing: border-box;
  background-color: #f5f7fb;
  border-right: 1px solid #d4d9e2;
  overflow-y: auto;
  font-family: inherit;
  font-size: 0.8rem;
  line-height: 1.6;
}

.sidebar-nav a {
  color: #1d3b70;
  text-decoration: none;
}

.sidebar-nav a:hover,
.sidebar-nav a:focus {
  text-decoration: underline;
}

.nav-upper {
  list-style: none;
  margin: 0;
  padding: 0;
}

.nav-upper > .nav-upper-item {
  margin-bottom: 14px;
}

.nav-upper > .nav-upper-item > a {
  display: inline-block;
  font-weight: 600;
  padding: 4px 0;
}

.nav-lower {
  list-style: none;
  margin: 8px 0 0 18px;
  padding: 0;
  border-left: 2px solid #c5cde0;
}

.nav-lower-item {
  margin: 4px 0;
}

.nav-lower-item a {
  display: inline-block;
  padding: 3px 0 3px 10px;
  color: #2f4d88;
}
</style>

</head>
<body>
<h2 id="page_top">SpringBoot依存関係解析機能要求一覧</h2>

<table>
  <tbody class="upper_request">
    <tr>
      <td id="upper-001" colspan="5">■ 基本型依存関係の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-001</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションのクラス間の基本型依存関係を、ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ クラス間の基本的な依存関係（継承、実装、型参照等）を把握することで、クラス構造の理解と変更影響範囲の特定が可能になる<br />・ コードリファクタリング時の依存関係の可視化により、安全な変更が可能になる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: 基本型依存関係とは、クラスの継承（extends）、インタフェース実装（implements）、ジェネリクス型参照、例外型依存などの型レベルでの依存関係を指す<br />・ 範囲: 型依存、メソッド依存、フィールド依存の3つのサブカテゴリを含む<br />・ 例: クラスAがクラスBを継承している場合、A→Bの型依存関係が存在する</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-001" colspan="4">■ 継承（extends）の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.001</td>
      <td>要求</td>
      <td colspan="2">クラスが別のクラスを継承している依存関係を、`.java`ソースコードのClass宣言部を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ クラスの継承関係を可視化することで、クラス階層の理解と変更影響範囲の特定が可能になる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 継承とは、クラスが別のクラスを継承して機能を拡張している状態を指す<br />・ 範囲: JavaParserを使用してASTパースで`ClassOrInterfaceDeclaration.getExtendedTypes()`を抽出し、親クラス依存を記録する<br />・ 例: `class Child extends Parent`の場合、Child→Parentの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 継承（extends）の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`ソースコード（Class宣言部）を対象に継承（extends）を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParser / jdepsを用いてASTパースで`ClassOrInterfaceDeclaration.getExtendedTypes()`を抽出し、親クラス依存を記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに継承（extends）（クラスが別のクラスを継承して機能を拡張している状態）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-002" colspan="4">■ 実装（implements）の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.002</td>
      <td>要求</td>
      <td colspan="2">クラスがインタフェースを実装している依存関係を、`.java`ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ インタフェース実装関係を可視化することで、契約に沿った実装を確認できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 実装とは、インタフェースを実装し、契約に沿って動作を保証する関係を指す<br />・ 範囲: JavaParserを使用して実装対象インタフェースを抽出（`getImplementedTypes`）し依存として記録する<br />・ 例: `class ServiceImpl implements Service`の場合、ServiceImpl→Serviceの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 実装（implements）の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`ソースコードを対象に実装（implements）を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParser / jdepsを用いて実装対象インタフェースを抽出(`getImplementedTypes`)し依存として記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに実装（implements）（インタフェースを実装し、契約に沿って動作を保証する関係）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-003" colspan="4">■ ジェネリクス型参照の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.003</td>
      <td>要求</td>
      <td colspan="2">コレクションや汎用型の実型引数による依存関係を、`.java`ソースコードの型引数を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ ジェネリクス型の実型引数を可視化することで、型パラメータの依存関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: ジェネリクス型参照とは、コレクションや汎用型の実型引数による依存を指す<br />・ 範囲: JavaParserを使用して`Type`/`ClassOrInterfaceType`の`getTypeArguments()`で参照型を抽出する<br />・ 例: `List&lt;String&gt;`の場合、List→Stringの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ ジェネリクス型参照の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.003-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（型引数）を対象にジェネリクス型参照を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`Type`/`ClassOrInterfaceType`の`getTypeArguments()`で参照型を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにジェネリクス型参照（コレクションや汎用型の実型引数による依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-004" colspan="4">■ 例外型依存の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.004</td>
      <td>要求</td>
      <td colspan="2">`throws`句や`catch`節で依存する例外型を、`.java`ソースコードのメソッド宣言/try-catchを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 例外型の依存関係を可視化することで、例外処理の設計を確認できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 例外型依存とは、`throws`句や`catch`節で依存する例外型を指す<br />・ 範囲: JavaParserを使用して`MethodDeclaration.getThrownExceptions()`/`CatchClause.getParameter()`を収集する<br />・ 例: `public void method() throws IOException`の場合、method→IOExceptionの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 例外型依存の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.004-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（メソッド宣言/try-catch）を対象に例外型依存を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`MethodDeclaration.getThrownExceptions()`/`CatchClause.getParameter()`を収集。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに例外型依存（`throws`句や`catch`節で依存する例外型）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-005" colspan="4">■ メソッド呼び出しの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.005</td>
      <td>要求</td>
      <td colspan="2">他クラスのメソッドを呼び出している依存関係を、`.java`ソースコードまたは実行時JVMトレースを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ メソッド呼び出し関係を可視化することで、クラス間の相互作用を理解できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: メソッド呼び出しとは、他クラスのメソッドを呼び出して動作を委譲している状態を指す<br />・ 範囲: JavaParser（静的）で`MethodCallExpr`を抽出、またはBTrace/JVMTI（動的）でJVMで実行時コールグラフを収集する<br />・ 例: `service.method()`の場合、呼び出し元→serviceクラスの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ メソッド呼び出しの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.005-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`ソースコードor実行時JVMトレースを対象にメソッド呼び出しを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParser(静的) / BTrace/JVMTI(動的)を用いて`MethodCallExpr`を抽出（静的）。動的はJVMで実行時コールグラフを収集。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにメソッド呼び出し（他クラスのメソッドを呼び出して動作を委譲している状態）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析or動的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-006" colspan="4">■ 戻り値型依存の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.006</td>
      <td>要求</td>
      <td colspan="2">メソッドの戻り値の型による依存関係を、`.java`ソースコードのメソッド宣言を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 戻り値型の依存関係を可視化することで、メソッドの返却値に依存する型を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 戻り値型依存とは、戻り値の型により呼び出し側が拘束される依存関係を指す<br />・ 範囲: JavaParserを使用して`MethodDeclaration.getType()`から依存型を記録する<br />・ 例: `public User getUser()`の場合、getUserメソッド→User型の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 戻り値型依存の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.006-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（メソッド宣言）を対象に戻り値型依存を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`MethodDeclaration.getType()`から依存型を記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに戻り値型依存（戻り値の型により呼び出し側が拘束される）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-007" colspan="4">■ 引数型依存の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.007</td>
      <td>要求</td>
      <td colspan="2">メソッドの引数型による依存関係を、`.java`ソースコードのメソッド宣言を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 引数型の依存関係を可視化することで、呼び出し側に要求する引数型を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 引数型依存とは、呼び出し側に要求する引数型の依存を指す<br />・ 範囲: JavaParserを使用して`MethodDeclaration.getParameters()`の型を抽出する<br />・ 例: `public void process(User user)`の場合、processメソッド→User型の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 引数型依存の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.007-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（メソッド宣言）を対象に引数型依存を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`MethodDeclaration.getParameters()`の型を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに引数型依存（呼び出し側に要求する引数型の依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-008" colspan="4">■ 静的メソッド依存の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.008</td>
      <td>要求</td>
      <td colspan="2">`ClassName.staticMethod()`の利用による依存関係を、`.java`ソースコードのメソッド呼び出しを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 静的メソッド呼び出しを可視化することで、クラス間の静的依存関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 静的メソッド依存とは、`ClassName.staticMethod()`の利用依存を指す<br />・ 範囲: JavaParserを使用して`MethodCallExpr`の`getScope()`が`NameExpr`/`FieldAccessExpr`で静的呼び出しを識別する<br />・ 例: `Utils.helper()`の場合、呼び出し元→Utilsクラスの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 静的メソッド依存の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.008-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（メソッド呼び出し）を対象に静的メソッド依存を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`MethodCallExpr`の`getScope()`が`NameExpr`/`FieldAccessExpr`で静的呼び出しを識別。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに静的メソッド依存（`ClassName.staticMethod()`の利用依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-009" colspan="4">■ コンポジション（保持）の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.009</td>
      <td>要求</td>
      <td colspan="2">クラス内部で他クラスのインスタンスをフィールドとして保持している依存関係を、`.java`ソースコードのField宣言部を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ コンポジション関係を可視化することで、クラス間の包含関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: コンポジション（保持）とは、クラス内部で他クラスのインスタンスをフィールドとして保持し、機能を委譲している状態を指す<br />・ 範囲: JavaParserを使用して`FieldDeclaration.getElementType()`から型依存を抽出する<br />・ 例: `private Service service;`の場合、クラス→Service型の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ コンポジション（保持）の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.009-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`ソースコード（Field宣言部）を対象にコンポジション（保持）を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`FieldDeclaration.getElementType()`から型依存を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにコンポジション（保持）（クラス内部で他クラスのインスタンスをフィールドとして保持し、機能を委譲している状態）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-010" colspan="4">■ 集合保持の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.010</td>
      <td>要求</td>
      <td colspan="2">`List&lt;T&gt;`などコレクションに格納する型への依存関係を、`.java`ソースコードのフィールド宣言を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ コレクションに格納される型を可視化することで、データ構造の依存関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 集合保持とは、`List&lt;T&gt;`などコレクションに格納する型への依存を指す<br />・ 範囲: JavaParserを使用してフィールド型のパラメータ化型から実型引数を抽出する<br />・ 例: `private List&lt;User&gt; users;`の場合、クラス→User型の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 集合保持の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.010-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（フィールド宣言）を対象に集合保持を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてフィールド型のパラメータ化型から実型引数を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに集合保持（`List&lt;T&gt;`などコレクションに格納する型への依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-001-011" colspan="4">■ 定数参照の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-001.011</td>
      <td>要求</td>
      <td colspan="2">`OtherClass.CONST`の参照による依存関係を、`.java`ソースコードのQualifiedNameを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 定数参照を可視化することで、クラス間の定数依存関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 定数参照とは、`OtherClass.CONST`の参照依存を指す<br />・ 範囲: JavaParserを使用して`FieldAccessExpr`/`NameExpr`解析で`static final`定数参照を記録する<br />・ 例: `Constants.MAX_SIZE`の場合、参照元→Constantsクラスの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 定数参照の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-001.011-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（QualifiedName）を対象に定数参照を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`FieldAccessExpr`/`NameExpr`解析で`staticfinal`定数参照を記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに定数参照（`OtherClass.CONST`の参照依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="upper_request">
    <tr>
      <td id="upper-002" colspan="5">■ DI（依存性注入）依存関係の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-002</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションのDI（依存性注入）パターンによる依存関係を、ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ Spring Frameworkの依存性注入パターンを可視化することで、Beanの依存関係とライフサイクルを理解できる<br />・ DI設定の不整合や循環依存を早期に発見できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: DI依存関係とは、コンストラクタ、フィールド、セッター、@Beanメソッドなどを通じた依存性注入による依存関係を指す<br />・ 範囲: Setter DI、@Bean提供、コンストラクタDI、フィールドDI、Spring依存（@RestController、@Service、@Repository）を含む<br />・ 例: クラスAのコンストラクタでクラスBのインスタンスを受け取る場合、A→BのDI依存関係が存在する</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-002-001" colspan="4">■ SetterDIの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-002.001</td>
      <td>要求</td>
      <td colspan="2">セッタにより依存を注入するパターンの依存関係を、`.java`ソースコードのメソッド注釈を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ Setter DIによる依存関係を可視化することで、DIパターンの把握が可能になる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: SetterDIとは、セッタにより依存を注入するパターンを指す<br />・ 範囲: JavaParserを使用して`MethodDeclaration`に`@Autowired`かつ`set*`命名を検出する<br />・ 例: `@Autowired public void setService(Service service)`の場合、クラス→Service型の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ SetterDIの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-002.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（メソッド注釈）を対象にSetterDIを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`MethodDeclaration`に`@Autowired`かつ`set*`命名を検出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにSetterDI（セッタにより依存を注入するパターン）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-002-002" colspan="4">■ @Bean提供の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-002.002</td>
      <td>要求</td>
      <td colspan="2">`@Configuration`内の`@Bean`でBeanを生成する依存関係を、`.java`ソースコードの@Beanメソッドを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ @Bean提供による依存関係を可視化することで、Bean定義の把握が可能になる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: @Bean提供とは、`@Configuration`内の`@Bean`でBeanを生成する依存を指す<br />・ 範囲: JavaParserを使用して戻り値型＝Bean型として依存登録する<br />・ 例: `@Bean public Service service()`の場合、Configuration→Service型の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ @Bean提供の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-002.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（@Beanメソッド）を対象に@Bean提供を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて戻り値型＝Bean型として依存登録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに@Bean提供（`@Configuration`内の`@Bean`でBeanを生成する依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-002-003" colspan="4">■ コンストラクタDIの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-002.003</td>
      <td>要求</td>
      <td colspan="2">コンストラクタを使って注入された依存オブジェクトの依存関係を、`.java`ソースコードのコンストラクタ定義部を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ コンストラクタDIによる依存関係を可視化することで、推奨されるDIパターンの把握が可能になる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: コンストラクタDIとは、コンストラクタを使って注入された依存オブジェクトを利用するパターンを指す<br />・ 範囲: JavaParserを使用して`ConstructorDeclaration`の引数型と`@Autowired`検出による依存関係抽出する<br />・ 例: `public Controller(Service service)`の場合、Controller→Service型の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ コンストラクタDIの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-002.003-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java` ソースコード（コンストラクタ定義部）を対象にコンストラクタDIを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`ConstructorDeclaration` の引数型と`@Autowired`検出による依存関係抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにコンストラクタDI（コンストラクタを使って注入された依存オブジェクトを利用するパターン）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-002-004" colspan="4">■ フィールドDIの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-002.004</td>
      <td>要求</td>
      <td colspan="2">フィールドに対して`@Autowired`で依存注入される依存関係を、`.java`ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ フィールドDIによる依存関係を可視化することで、DIパターンの把握が可能になる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: フィールドDIとは、フィールドに対して`@Autowired`で依存注入されるパターンを指す<br />・ 範囲: JavaParserを使用して`FieldDeclaration`に対するアノテーション解析でDI情報を抽出する<br />・ 例: `@Autowired private Service service;`の場合、クラス→Service型の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ フィールドDIの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-002.004-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java` ソースコードを対象にフィールドDIを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`FieldDeclaration`に対するアノテーション解析でDI情報を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにフィールドDI（フィールドに対して`@Autowired`で依存注入されるパターン）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-002-005" colspan="4">■ コントローラ定義の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-002.005</td>
      <td>要求</td>
      <td colspan="2">Spring MVCでHTTPリクエストを受け取るクラスの依存関係を、`.java`ソースコードの@RestController注釈を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ コントローラ定義を可視化することで、Web層の依存関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: コントローラ定義とは、Spring MVCでHTTPリクエストを受け取るクラスを指す<br />・ 範囲: JavaParserを使用して`@RestController`を検出し、Web依存として分類する<br />・ 例: `@RestController public class UserController`の場合、UserControllerがWeb層として識別される</td>
    </tr>
    <tr>
      <td colspan="3">■ コントローラ定義の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-002.005-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（@RestController注釈）を対象にコントローラ定義を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`@RestController`を検出 → Web依存として分類。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにコントローラ定義（Spring MVC でHTTPリクエストを受け取るクラス）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-002-006" colspan="4">■ サービス層定義の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-002.006</td>
      <td>要求</td>
      <td colspan="2">業務ロジックを担う`@Service`Beanの依存関係を、`.java`ソースコードのクラス注釈を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ サービス層定義を可視化することで、業務ロジック層の依存関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: サービス層定義とは、業務ロジックを担う`@Service`Beanを指す<br />・ 範囲: JavaParserを使用して`@Service`検出でSpring Core依存としてマークする<br />・ 例: `@Service public class UserService`の場合、UserServiceがサービス層として識別される</td>
    </tr>
    <tr>
      <td colspan="3">■ サービス層定義の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-002.006-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（クラス注釈）を対象にサービス層定義を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`@Service`検出でSpring Core依存としてマーク。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにサービス層定義（業務ロジックを担う`@Service`Bean）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-002-007" colspan="4">■ リポジトリ層定義の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-002.007</td>
      <td>要求</td>
      <td colspan="2">DAO役の`@Repository`Beanの依存関係を、`.java`ソースコードのクラス注釈/継承を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ リポジトリ層定義を可視化することで、データアクセス層の依存関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: リポジトリ層定義とは、DAO役の`@Repository`Beanを指す<br />・ 範囲: JavaParserを使用して`@Repository`または`*Repository`命名/`JpaRepository`継承を検出する<br />・ 例: `@Repository public interface UserRepository extends JpaRepository&lt;User, Long&gt;`の場合、UserRepositoryがリポジトリ層として識別される</td>
    </tr>
    <tr>
      <td colspan="3">■ リポジトリ層定義の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-002.007-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（クラス注釈/継承）を対象にリポジトリ層定義を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`@Repository`または`*Repository`命名/`JpaRepository`継承を検出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにリポジトリ層定義（DAO役の`@Repository`Bean）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="upper_request">
    <tr>
      <td id="upper-003" colspan="5">■ 永続化層依存関係の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-003</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションの永続化層（Repository、Entity、DTO）の依存関係を、ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ データベーススキーマとアプリケーションコードの対応関係を明確にすることで、データモデル変更時の影響範囲を特定できる<br />・ DTOとEntityの変換関係を可視化することで、データフローを理解できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: 永続化層依存関係とは、JPAリポジトリ、JPAエンティティ、DTO、マッパーなどのデータアクセス層の依存関係を指す<br />・ 範囲: Repository依存、DTO/Entity依存を含む<br />・ 例: RepositoryインタフェースがJpaRepository&lt;User, Long&gt;を継承している場合、Repository→User（Entity）の依存関係が存在する</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-003-001" colspan="4">■ JPAリポジトリの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-003.001</td>
      <td>要求</td>
      <td colspan="2">DB操作を抽象化した永続化処理のインタフェースの依存関係を、`.java`ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ JPAリポジトリの依存関係を可視化することで、データアクセス層の構造を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: JPAリポジトリとは、DB操作を抽象化した永続化処理のインタフェースを指す<br />・ 範囲: JavaParserを使用して`ClassOrInterfaceDeclaration`が`JpaRepository`を継承しているか確認する<br />・ 例: `interface UserRepository extends JpaRepository&lt;User, Long&gt;`の場合、UserRepository→JpaRepositoryの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ JPAリポジトリの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-003.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`を対象にJPAリポジトリを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`ClassOrInterfaceDeclaration` が `JpaRepository` を継承しているか確認。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにJPAリポジトリ（DB操作を抽象化した永続化処理のインタフェース）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-003-002" colspan="4">■ JPAエンティティの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-003.002</td>
      <td>要求</td>
      <td colspan="2">`@Entity`でDBテーブルとマッピングするクラスの依存関係を、`.java`ソースコードのクラス注釈/フィールドを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ JPAエンティティの依存関係を可視化することで、データモデルとスキーマの対応関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: JPAエンティティとは、`@Entity`でDBテーブルとマッピングするクラスを指す<br />・ 範囲: JavaParserを使用して`@Entity`/`@Id`/`@Column`を抽出してスキーマ依存を記録する<br />・ 例: `@Entity public class User`の場合、Userがエンティティとして識別され、DBテーブルへの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ JPAエンティティの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-003.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（クラス注釈/フィールド）を対象にJPAエンティティを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`@Entity`/`@Id`/`@Column`を抽出してスキーマ依存を記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにJPAエンティティ（`@Entity`でDBテーブルとマッピング）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-003-003" colspan="4">■ クエリメソッドの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-003.003</td>
      <td>要求</td>
      <td colspan="2">メソッド名規約や`@Query`による依存関係を、`.java`ソースコードのRepositoryインタフェースを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ クエリメソッドの依存関係を可視化することで、SQL/JPQLの参照関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: クエリメソッドとは、メソッド名規約や`@Query`による依存を指す<br />・ 範囲: JavaParserを使用して`MethodDeclaration`名規約/`@Query`文字列を収集し、SQL/JPQL参照も注記する<br />・ 例: `@Query(&quot;SELECT u FROM User u WHERE u.name = :name&quot;)`の場合、Repository→Userエンティティの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ クエリメソッドの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-003.003-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（Repositoryインタフェース）を対象にクエリメソッドを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`MethodDeclaration`名規約/`@Query`文字列を収集（SQL/JPQL参照も注記）。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにクエリメソッド（メソッド名規約や`@Query`による依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-003-004" colspan="4">■ DTOの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-003.004</td>
      <td>要求</td>
      <td colspan="2">I/O向け転送モデルの依存関係を、`.java`ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ DTOの依存関係を可視化することで、データ転送オブジェクトの構造を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: DTOとは、I/O向け転送モデル依存を指す<br />・ 範囲: JavaParserを使用してDTOパッケージ/純データクラス（record/POJO）検出する<br />・ 例: DTOパッケージ内のクラスは、DTOとして識別される</td>
    </tr>
    <tr>
      <td colspan="3">■ DTOの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-003.004-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`を対象にDTOを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてDTOパッケージ/純データクラス（record/POJO）検出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにDTO（I/O向け転送モデル依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-003-005" colspan="4">■ マッパーの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-003.005</td>
      <td>要求</td>
      <td colspan="2">DTO?Entity変換層の依存関係（MapStruct等）を、`.java`ソースコードの@Mapperを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ マッパーの依存関係を可視化することで、DTOとEntityの変換関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: マッパーとは、DTO?Entity変換層の依存（MapStruct等）を指す<br />・ 範囲: JavaParserを使用して`@Mapper`/`@Mapping`とメソッドシグネチャで変換関係を記録する<br />・ 例: `@Mapper public interface UserMapper`の場合、UserMapper→DTO/Entityの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ マッパーの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-003.005-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（@Mapper）を対象にマッパーを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`@Mapper`/`@Mapping`とメソッドシグネチャで変換関係を記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにマッパー（DTO?Entity変換層の依存（MapStruct等））のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="upper_request">
    <tr>
      <td id="upper-004" colspan="5">■ 設定・構成依存関係の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-004</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションの設定値、プロファイル、ビルド構成による依存関係を、ソースコードと設定ファイルを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ 設定値とコードの対応関係を明確にすることで、設定変更時の影響範囲を特定できる<br />・ ビルド依存関係を可視化することで、ライブラリのバージョン管理とセキュリティ脆弱性の影響範囲を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: 設定・構成依存関係とは、@Value注入、@ConfigurationProperties、プロファイル条件、オートコンフィグ、Maven/Gradle依存などの構成要素による依存関係を指す<br />・ 範囲: 設定値依存、設定/プロファイル、構成/起動、ビルド依存を含む<br />・ 例: @Value(&quot;${app.name}&quot;)で設定値を注入している場合、クラス→設定ファイルの依存関係が存在する</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-004-001" colspan="4">■ @Value注入の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-004.001</td>
      <td>要求</td>
      <td colspan="2">設定プレースホルダ`${...}`の依存関係を、`.java`ソースコードの@Valueと`application*.yml`を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ @Value注入の依存関係を可視化することで、設定値とコードの対応関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: @Value注入とは、設定プレースホルダ`${...}`の依存を指す<br />・ 範囲: JavaParserとYAMLパーサを使用して`@Value`キーを抽出し、設定ファイル側のキー存在も静的に照合する<br />・ 例: `@Value(&quot;${app.name}&quot;)`の場合、クラス→設定ファイルの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ @Value注入の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-004.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（@Value）/`application*.yml`を対象に@Value注入を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParser / YAMLパーサを用いて`@Value`キーを抽出し設定ファイル側のキー存在も静的に照合。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに@Value注入（設定プレースホルダ`${...}`の依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-004-002" colspan="4">■ 構成プロパティの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-004.002</td>
      <td>要求</td>
      <td colspan="2">`@ConfigurationProperties`の型安全バインド依存関係を、`.java`ソースコードの@ConfigurationPropertiesとYAMLを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 構成プロパティの依存関係を可視化することで、設定値の型安全なバインド関係を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 構成プロパティとは、`@ConfigurationProperties`の型安全バインド依存を指す<br />・ 範囲: JavaParserとYAMLパーサを使用してprefix配下のキー群→プロパティクラスのフィールド構造にマップする<br />・ 例: `@ConfigurationProperties(prefix = &quot;app&quot;)`の場合、プロパティクラス→設定ファイルの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 構成プロパティの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-004.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（@ConfigurationProperties）/YAMLを対象に構成プロパティを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParser / YAMLパーサを用いてprefix配下のキー群→プロパティクラスのフィールド構造にマップ。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに構成プロパティ（`@ConfigurationProperties`の型安全バインド依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-004-003" colspan="4">■ プロファイル条件の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-004.003</td>
      <td>要求</td>
      <td colspan="2">`@Profile`/`@Conditional`の条件依存関係を、`.java`ソースコードの注釈と環境を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ プロファイル条件の依存関係を可視化することで、環境ごとのBean有効化条件を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: プロファイル条件とは、`@Profile`/`@Conditional`の条件依存を指す<br />・ 範囲: JavaParserを使用してプロファイル名/条件クラス→有効Beanの分岐点として記録する<br />・ 例: `@Profile(&quot;dev&quot;)`の場合、Beanがdevプロファイルでのみ有効であることが記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ プロファイル条件の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-004.003-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（注釈）/環境を対象にプロファイル条件を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてプロファイル名/条件クラス→有効Beanの分岐点として記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにプロファイル条件（`@Profile`/`@Conditional`の条件依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-004-004" colspan="4">■ オートコンフィグの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-004.004</td>
      <td>要求</td>
      <td colspan="2">Starter導入で自動登録されるBean依存関係を、`pom.xml`/`META-INF/*`を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ オートコンフィグの依存関係を可視化することで、自動的に有効化されるBeanを把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: オートコンフィグとは、Starter導入で自動登録されるBean依存を指す<br />・ 範囲: Maven依存解析とjdepsを使用してPOMの`spring-boot-starter-*`から推定し、`spring.factories`/`AutoConfiguration`を一覧化する<br />・ 例: `spring-boot-starter-web`を導入すると、Web関連のBeanが自動的に有効化される</td>
    </tr>
    <tr>
      <td colspan="3">■ オートコンフィグの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-004.004-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`pom.xml`/`META-INF/*`を対象にオートコンフィグを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>Maven依存解析 / jdepsを用いてPOMの`spring-boot-starter-*`から推定、`spring.factories`/`AutoConfiguration`を一覧化。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにオートコンフィグ（Starter導入で自動登録されるBean依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-004-005" colspan="4">■ ビルド依存の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-004.005</td>
      <td>要求</td>
      <td colspan="2">Maven/Gradleの依存範囲（scope）や伝播依存の依存関係を、`pom.xml`/`build.gradle`を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ ビルド依存の依存関係を可視化することで、実行クラスパスを確定できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: ビルド依存とは、Maven/Gradleの依存範囲（scope）や伝播依存の影響を指す<br />・ 範囲: Maven、Gradle依存解決を使用して依存ツリーを出力（`mvn dependency:tree`）して実行クラスパスを確定する<br />・ 例: `pom.xml`の依存関係から、実行時に利用可能なライブラリの一覧を取得する</td>
    </tr>
    <tr>
      <td colspan="3">■ ビルド依存の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-004.005-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`pom.xml`/`build.gradle`を対象にMaven/Gradleを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>Maven / Gradle依存解決を用いて依存ツリーを出力（`mvn dependency:tree`）して実行クラスパスを確定。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにMaven/Gradle（依存範囲（scope）や伝播依存の影響）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="upper_request">
    <tr>
      <td id="upper-005" colspan="5">■ 外部サービス・イベント依存関係の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-005</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションの外部サービス連携とイベント処理による依存関係を、ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ 外部サービスとの連携を可視化することで、外部システム変更時の影響範囲を特定できる<br />・ イベント駆動アーキテクチャにおけるイベント発行・購読関係を把握することで、非同期処理のフローを理解できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: 外部サービス・イベント依存関係とは、HTTPクライアント、メッセージング、アプリケーションイベントなどの外部連携による依存関係を指す<br />・ 範囲: イベント依存、外部サービス依存（HTTPクライアント、メッセージング）を含む<br />・ 例: @FeignClientで外部APIを呼び出している場合、クラス→外部サービスの依存関係が存在する</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-005-001" colspan="4">■ アプリイベント購読の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-005.001</td>
      <td>要求</td>
      <td colspan="2">`@EventListener`でイベント発生元への依存関係を、`.java`ソースコードの@EventListenerを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ アプリイベント購読の依存関係を可視化することで、イベント駆動アーキテクチャのフローを把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: アプリイベント購読とは、`@EventListener`でイベント発生元へ依存する関係を指す<br />・ 範囲: JavaParserを使用して引数/注釈値のイベント型を抽出し、発行側との依存を記録する<br />・ 例: `@EventListener public void handle(UserCreatedEvent event)`の場合、ハンドラ→UserCreatedEventの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ アプリイベント購読の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-005.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（@EventListener）を対象にアプリイベント購読を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて引数/注釈値のイベント型を抽出し発行側との依存を記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにアプリイベント購読（`@EventListener`でイベント発生元へ依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-005-002" colspan="4">■ HTTPクライアントの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-005.002</td>
      <td>要求</td>
      <td colspan="2">`WebClient`/`RestTemplate`/`@FeignClient`による外部サービス依存関係を、`.java`ソースコードの型/注釈/URL文字列を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ HTTPクライアントの依存関係を可視化することで、外部サービス連携の全体像を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: HTTPクライアントとは、`WebClient`/`RestTemplate`/`@FeignClient`による外部サービス連携を指す<br />・ 範囲: JavaParserを使用してインスタンス化/`@FeignClient(name,url)`/HTTPメソッド呼び出しを抽出する<br />・ 例: `@FeignClient(name = &quot;user-service&quot;, url = &quot;http://api.example.com&quot;)`の場合、クラス→外部サービスの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ HTTPクライアントの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-005.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（型/注釈/URL文字列）を対象にHTTPクライアントを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてインスタンス化/`@FeignClient(name,url)`/HTTPメソッド呼び出しを抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにHTTPクライアント（`WebClient`/`RestTemplate`/`@FeignClient`）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-005-003" colspan="4">■ メッセージングの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-005.003</td>
      <td>要求</td>
      <td colspan="2">`@KafkaListener`/`@RabbitListener`等による依存関係を、`.java`ソースコードのリスナ注釈/Template型を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ メッセージングの依存関係を可視化することで、非同期メッセージ処理のフローを把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: メッセージングとは、`@KafkaListener`/`@RabbitListener`等のメッセージング依存を指す<br />・ 範囲: JavaParserを使用してTopic/Queue名（文字列）とハンドラメソッドを対応付ける<br />・ 例: `@KafkaListener(topics = &quot;user-events&quot;)`の場合、リスナ→Kafkaトピックの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ メッセージングの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-005.003-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（リスナ注釈/Template型）を対象にメッセージングを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてTopic/Queue名（文字列）とハンドラメソッドを対応付け。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにメッセージング（`@KafkaListener`/`@RabbitListener`等の依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="upper_request">
    <tr>
      <td id="upper-006" colspan="5">■ 横断的関心事依存関係の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-006</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションの横断的関心事（AOP、観測性、バリデーション）による依存関係を、ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ 横断的関心事の適用範囲を可視化することで、AOP設定の影響範囲を理解できる<br />・ 観測性（ログ、メトリクス）の計測ポイントを把握することで、運用監視の方針を立てられる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: 横断的関心事依存関係とは、AOP（トランザクション、アスペクト）、観測性（ログ、メトリクス）、国際化/バリデーションなどの横断的な機能による依存関係を指す<br />・ 範囲: AOP依存、観測性、国際化/バリデーションを含む<br />・ 例: @Transactionalアノテーションが付与されているメソッドは、トランザクション管理機能への依存関係が存在する</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-006-001" colspan="4">■ トランザクションの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-006.001</td>
      <td>要求</td>
      <td colspan="2">`@Transactional`でTx境界に依存する関係を、`.java`ソースコードの注釈または実行ログを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ トランザクションの依存関係を可視化することで、トランザクション管理の適用範囲を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: トランザクションとは、`@Transactional`でTx境界に依存する関係を指す<br />・ 範囲: JavaParser（静的）で注釈抽出、必要に応じてSpring Actuator（動的）で実行時にTx境界/プロパゲーションをログで確認する<br />・ 例: `@Transactional`が付与されているメソッドは、トランザクション管理機能への依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ トランザクションの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-006.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（注釈）/実行ログを対象にトランザクションを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParser / Spring Actuatorを用いて静的に注釈抽出＋必要に応じて実行時にTx境界/プロパゲーションをログで確認。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにトランザクション（`@Transactional`でTx境界に依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析 or 動的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-006-002" colspan="4">■ 横断的関心事の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-006.002</td>
      <td>要求</td>
      <td colspan="2">`@Aspect`/ポイントカットでの横断依存関係を、`.java`ソースコードのAspectJ注釈/式を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 横断的関心事の依存関係を可視化することで、AOPの適用範囲を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 横断的関心事とは、`@Aspect`/ポイントカットでの横断依存を指す<br />・ 範囲: JavaParserを使用して`@Aspect`/`@Around`のポイントカット式→対象JoinPoint群を列挙する<br />・ 例: `@Around(&quot;@annotation(Logging)&quot;)`の場合、アスペクト→Loggingアノテーション付与メソッドの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 横断的関心事の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-006.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（AspectJ注釈/式）を対象に横断的関心事を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`@Aspect`/`@Around`のポイントカット式→対象JoinPoint群を列挙。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに横断的関心事（`@Aspect`/ポイントカットでの横断依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-006-003" colspan="4">■ ログ/メトリクスの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-006.003</td>
      <td>要求</td>
      <td colspan="2">`Micrometer`や`@Timed`等の観測依存関係を、`.java`ソースコードの注釈/メトリクス登録または実行時メトリクスを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 観測性の依存関係を可視化することで、運用監視の方針を立てられる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: ログ/メトリクスとは、`Micrometer`や`@Timed`等の観測依存を指す<br />・ 範囲: JavaParser（静的）で計測ポイントを抽出、動的にActuator/Micrometerでメトリクスエンドポイントから稼働確認する<br />・ 例: `@Timed`が付与されているメソッドは、メトリクス収集機能への依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ ログ/メトリクスの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-006.003-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（注釈/メトリクス登録）/実行時メトリクスを対象にログ/メトリクスを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParser / Actuator/Micrometerを用いて静的に計測ポイントを抽出、動的にメトリクスエンドポイントから稼働確認。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにログ/メトリクス（`Micrometer`や`@Timed`等の観測依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析 or 動的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-006-004" colspan="4">■ Bean Validationの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-006.004</td>
      <td>要求</td>
      <td colspan="2">`@Valid`/`@NotNull`等の制約依存関係を、`.java`ソースコードの引数/フィールド注釈を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ Bean Validationの依存関係を可視化することで、データ検証の適用範囲を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: Bean Validationとは、`@Valid`/`@NotNull`等の制約依存を指す<br />・ 範囲: JavaParserを使用して制約注釈を抽出し、DTO/Entityの検証点を可視化する<br />・ 例: `@NotNull private String name;`の場合、フィールド→バリデーション機能の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ Bean Validationの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-006.004-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（引数/フィールド注釈）を対象にBean Validationを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて制約注釈を抽出し、DTO/Entityの検証点を可視化。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにBean Validation（`@Valid`/`@NotNull`等の制約依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="upper_request">
    <tr>
      <td id="upper-007" colspan="5">■ セキュリティ依存関係の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-007</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションのセキュリティ機能（認証、認可、フィルタ等）による依存関係を、ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ セキュリティ設定の全体像を可視化することで、セキュリティポリシーの一貫性を確認できる<br />・ 認証・認可の依存関係を把握することで、セキュリティ脆弱性の影響範囲を特定できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: セキュリティ依存関係とは、Spring Securityの設定、認証プロバイダ、認可ルール、JWT処理、CORS/CSRF設定などのセキュリティ機能による依存関係を指す<br />・ 範囲: Security依存（SecurityFilterChain、HttpSecurity、UserDetails、認証/認可/フィルタ関連）、セキュリティ補助（CORS/CSRF）を含む<br />・ 例: SecurityFilterChainでHTTPリクエストの保護ルールを定義している場合、設定→リソースの依存関係が存在する</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-001" colspan="4">■ SecurityFilterChain構成の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.001</td>
      <td>要求</td>
      <td colspan="2">Spring SecurityのHTTP保護設定を行う中心Beanの依存関係を、`.java`ソースコードの@Beanメソッドを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ SecurityFilterChain構成を可視化することで、セキュリティ設定の全体像を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: SecurityFilterChain構成とは、Spring SecurityのHTTP保護設定を行う中心Beanを指す<br />・ 範囲: JavaParserを使用して`MethodDeclaration`の戻り値型が`SecurityFilterChain`のメソッドを検出する<br />・ 例: `@Bean public SecurityFilterChain filterChain(HttpSecurity http)`の場合、SecurityFilterChain設定が識別される</td>
    </tr>
    <tr>
      <td colspan="3">■ SecurityFilterChain構成の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（@Beanメソッド）を対象にSecurityFilterChain構成を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`MethodDeclaration` の戻り値型が `SecurityFilterChain` のメソッドを検出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにSecurityFilterChain構成（Spring SecurityのHTTP保護設定を行う中心Bean）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-002" colspan="4">■ HttpSecurityルールの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.002</td>
      <td>要求</td>
      <td colspan="2">`.authorizeHttpRequests()`等の保護ルール依存関係を、`.java`ソースコードのSecurityConfigを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ HttpSecurityルールを可視化することで、HTTPリクエストの保護ルールを把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: HttpSecurityルールとは、`.authorizeHttpRequests()`等の保護ルール依存を指す<br />・ 範囲: JavaParserを使用して`HttpSecurity`メソッドチェーンから`requestMatchers`と権限要件を抽出する<br />・ 例: `http.authorizeHttpRequests().requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)`の場合、保護ルールが記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ HttpSecurityルールの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（SecurityConfig）を対象にHttpSecurityルールを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`HttpSecurity`メソッドチェーンから`requestMatchers`と権限要件を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにHttpSecurityルール（`.authorizeHttpRequests()`等の保護ルール依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-003" colspan="4">■ UserDetailsの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.003</td>
      <td>要求</td>
      <td colspan="2">ユーザ表現への依存関係（権限/有効期限等）を、`.java`ソースコードのUserDetails実装を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ UserDetailsの依存関係を可視化することで、ユーザ情報の表現方法を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: UserDetailsとは、ユーザ表現への依存（権限/有効期限等）を指す<br />・ 範囲: JavaParserを使用して`UserDetails`実装クラスと`GrantedAuthority`供給箇所を抽出する<br />・ 例: `class CustomUserDetails implements UserDetails`の場合、CustomUserDetails→UserDetailsの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ UserDetailsの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.003-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（UserDetails実装）を対象にUserDetailsを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`UserDetails`実装クラスと`GrantedAuthority`供給箇所を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにUserDetails（ユーザ表現への依存（権限/有効期限等））のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-004" colspan="4">■ UserDetailsServiceの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.004</td>
      <td>要求</td>
      <td colspan="2">ユーザ読込（DB/外部）の依存関係を、`.java`ソースコードのloadUserByUsernameを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ UserDetailsServiceの依存関係を可視化することで、認証データソースを把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: UserDetailsServiceとは、ユーザ読込（DB/外部）の依存を指す<br />・ 範囲: JavaParserを使用して実装クラス/データソース（Repository呼び出し）を追跡する<br />・ 例: `class CustomUserDetailsService implements UserDetailsService`の場合、認証→データソースの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ UserDetailsServiceの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.004-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（loadUserByUsername）を対象にUserDetailsServiceを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて実装クラス/データソース（Repository呼び出し）を追跡。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにUserDetailsService（ユーザ読込（DB/外部）の依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-005" colspan="4">■ PasswordEncoderの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.005</td>
      <td>要求</td>
      <td colspan="2">パスワードハッシュ方式の依存関係を、`.java`ソースコードの@Bean/参照を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ PasswordEncoderの依存関係を可視化することで、パスワードハッシュ方式を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: PasswordEncoderとは、パスワードハッシュ方式の依存を指す<br />・ 範囲: JavaParserを使用して`new BCryptPasswordEncoder()`等のBean定義・参照箇所を抽出する<br />・ 例: `@Bean public PasswordEncoder passwordEncoder()`の場合、Bean定義が記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ PasswordEncoderの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.005-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（@Bean/参照）を対象にPasswordEncoderを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`new BCryptPasswordEncoder()`等のBean定義・参照箇所を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにPasswordEncoder（パスワードハッシュ方式の依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-006" colspan="4">■ AuthenticationManagerの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.006</td>
      <td>要求</td>
      <td colspan="2">認証処理の起点への依存関係を、`.java`ソースコードのauthenticate呼び出しを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ AuthenticationManagerの依存関係を可視化することで、認証処理の起点を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: AuthenticationManagerとは、認証処理の起点への依存を指す<br />・ 範囲: JavaParserを使用して`AuthenticationManager#authenticate`呼び出し箇所を収集する<br />・ 例: `authenticationManager.authenticate(authentication)`の場合、呼び出し元→AuthenticationManagerの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ AuthenticationManagerの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.006-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（authenticate呼び出し）を対象にAuthenticationManagerを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`AuthenticationManager#authenticate`呼び出し箇所を収集。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにAuthenticationManager（認証処理の起点への依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-007" colspan="4">■ AuthenticationProviderの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.007</td>
      <td>要求</td>
      <td colspan="2">認証方式（DAO/JWT等）ごとの依存関係を、`.java`ソースコードのProvider実装を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ AuthenticationProviderの依存関係を可視化することで、認証方式の実装を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: AuthenticationProviderとは、認証方式（DAO/JWT等）ごとの依存を指す<br />・ 範囲: JavaParserを使用して`AuthenticationProvider`実装/Bean登録を抽出する<br />・ 例: `class CustomAuthenticationProvider implements AuthenticationProvider`の場合、Provider実装が記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ AuthenticationProviderの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.007-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（Provider実装）を対象にAuthenticationProviderを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`AuthenticationProvider`実装/Bean登録を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにAuthenticationProvider（認証方式（DAO/JWT等）ごとの依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-008" colspan="4">■ OncePerRequestFilterの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.008</td>
      <td>要求</td>
      <td colspan="2">リクエスト単位フィルタ依存関係（JWT等）を、`.java`ソースコードの継承/overrideを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ OncePerRequestFilterの依存関係を可視化することで、カスタムフィルタの実装を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: OncePerRequestFilterとは、リクエスト単位フィルタ依存（JWT等）を指す<br />・ 範囲: JavaParserを使用して`OncePerRequestFilter`継承/`doFilterInternal`実装を抽出する<br />・ 例: `class JwtFilter extends OncePerRequestFilter`の場合、JwtFilter→OncePerRequestFilterの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ OncePerRequestFilterの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.008-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（継承/override）を対象にOncePerRequestFilterを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`OncePerRequestFilter`継承/`doFilterInternal`実装を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにOncePerRequestFilter（リクエスト単位フィルタ依存（JWT等））のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-009" colspan="4">■ メソッドセキュリティの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.009</td>
      <td>要求</td>
      <td colspan="2">`@PreAuthorize`/`@PostAuthorize`の依存関係を、`.java`ソースコードのメソッド注釈を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ メソッドセキュリティの依存関係を可視化することで、メソッドレベルの認可ルールを把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: メソッドセキュリティとは、`@PreAuthorize`/`@PostAuthorize`の依存を指す<br />・ 範囲: JavaParserを使用してSpEL式を抽出しロール/権限・引数参照を記録する<br />・ 例: `@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)`の場合、メソッド→認可機能の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ メソッドセキュリティの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.009-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（メソッド注釈）を対象にメソッドセキュリティを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてSpEL式を抽出しロール/権限・引数参照を記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにメソッドセキュリティ（`@PreAuthorize`/`@PostAuthorize`の依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-010" colspan="4">■ ロール/権限の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.010</td>
      <td>要求</td>
      <td colspan="2">`ROLE_*`/`SCOPE_*`等の付与依存関係を、`.java`ソースコードのGrantedAuthority生成を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ ロール/権限の依存関係を可視化することで、アプリケーションで使用される権限を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: ロール/権限とは、`ROLE_*`/`SCOPE_*`等の付与依存を指す<br />・ 範囲: JavaParserを使用して`new SimpleGrantedAuthority(...)`のリテラルを取得して一覧化する<br />・ 例: `new SimpleGrantedAuthority(&quot;ROLE_ADMIN&quot;)`の場合、ロール定義が記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ ロール/権限の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.010-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（GrantedAuthority生成）を対象にロール/権限を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`new SimpleGrantedAuthority(...)` のリテラルを取得して一覧化。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにロール/権限（`ROLE_*`/`SCOPE_*`等の付与依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-011" colspan="4">■ SecurityContextの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.011</td>
      <td>要求</td>
      <td colspan="2">`SecurityContextHolder`参照依存関係を、`.java`ソースコードのAPI呼び出しを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ SecurityContextの依存関係を可視化することで、セキュリティコンテキストの利用箇所を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: SecurityContextとは、`SecurityContextHolder`参照依存を指す<br />・ 範囲: JavaParserを使用して`SecurityContextHolder.getContext()`呼び出し箇所を記録する<br />・ 例: `SecurityContextHolder.getContext().getAuthentication()`の場合、呼び出し元→SecurityContextの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ SecurityContextの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.011-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（API呼び出し）を対象にSecurityContextを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`SecurityContextHolder.getContext()`呼び出し箇所を記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにSecurityContext（`SecurityContextHolder`参照依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-012" colspan="4">■ Session管理の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.012</td>
      <td>要求</td>
      <td colspan="2">STATELESS/STATEFULなど方針依存関係を、`.java`ソースコードの`sessionManagement`設定を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ Session管理の依存関係を可視化することで、セッション管理方針を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: Session管理とは、STATELESS/STATEFULなど方針依存を指す<br />・ 範囲: JavaParserを使用して`sessionCreationPolicy`の設定値を抽出する<br />・ 例: `http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)`の場合、セッション管理方針が記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ Session管理の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.012-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（`sessionManagement`設定）を対象にSession管理を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`sessionCreationPolicy`の設定値を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにSession管理（STATELESS/STATEFULなど方針依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-013" colspan="4">■ トークン抽出の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.013</td>
      <td>要求</td>
      <td colspan="2">`Authorization: Bearer`ヘッダ処理への依存関係を、`.java`ソースコードのFilterまたはHTTPトレースを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ トークン抽出の依存関係を可視化することで、JWT認証の実装を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: トークン抽出とは、`Authorization: Bearer`ヘッダ処理への依存を指す<br />・ 範囲: JavaParser（静的）でヘッダ読取/前置詞`Bearer`検出。必要ならSpring Cloud Sleuth（動的）で実行時トレースで確認する<br />・ 例: Filterで`Authorization`ヘッダから`Bearer`トークンを抽出する場合、トークン抽出処理が記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ トークン抽出の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.013-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（Filter）/HTTPトレースを対象にトークン抽出を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParser / Spring Cloud Sleuthを用いてヘッダ読取/前置詞`Bearer`検出。必要なら実行時トレースで確認。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにトークン抽出（`Authorization: Bearer`ヘッダ処理への依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析 or 動的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-014" colspan="4">■ 署名/検証の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.014</td>
      <td>要求</td>
      <td colspan="2">鍵・アルゴリズムによるJWS検証依存関係を、`.java`ソースコードのJWTライブラリ呼び出しを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 署名/検証の依存関係を可視化することで、JWT検証の実装を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 署名/検証とは、鍵・アルゴリズムによるJWS検証依存を指す<br />・ 範囲: JavaParserを使用してライブラリ（Nimbus等）のVerifier/Parser呼び出しと鍵取得元を特定する<br />・ 例: JWTライブラリでトークンの署名を検証する場合、検証処理→鍵/アルゴリズムの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ 署名/検証の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.014-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（JWTライブラリ呼び出し）を対象に署名/検証を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてライブラリ（Nimbus等）のVerifier/Parser呼び出しと鍵取得元を特定。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに署名/検証（鍵・アルゴリズムによるJWS検証依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-015" colspan="4">■ クレーム→権限の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.015</td>
      <td>要求</td>
      <td colspan="2">`claims`から`GrantedAuthority`へ変換する依存関係を、`.java`ソースコードのマッピング関数を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ クレーム→権限の依存関係を可視化することで、JWTクレームから権限への変換ロジックを把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: クレーム→権限とは、`claims`から`GrantedAuthority`へ変換する依存を指す<br />・ 範囲: JavaParserを使用してクレーム名（roles/authorities等）→`SimpleGrantedAuthority`生成の対応付けを行う<br />・ 例: JWTの`roles`クレームから`GrantedAuthority`を生成する場合、変換ロジックが記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ クレーム→権限の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.015-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（マッピング関数）を対象にクレーム→権限を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてクレーム名（roles/authorities等）→`SimpleGrantedAuthority`生成の対応付け。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにクレーム→権限（`claims`から`GrantedAuthority`へ変換）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-016" colspan="4">■ ログイン/ログアウトの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.016</td>
      <td>要求</td>
      <td colspan="2">`/login`等のエンドポイント保護依存関係を、`.java`ソースコードの`formLogin`/`logout`設定を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ ログイン/ログアウトの依存関係を可視化することで、認証エンドポイントの設定を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: ログイン/ログアウトとは、`/login`等のエンドポイント保護依存を指す<br />・ 範囲: JavaParserを使用して`HttpSecurity`の`formLogin`/`logout`設定値を抽出する<br />・ 例: `http.formLogin().loginPage(&quot;/login&quot;)`の場合、ログインエンドポイント設定が記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ ログイン/ログアウトの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.016-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（`formLogin`/`logout`設定）を対象にログイン/ログアウトを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`HttpSecurity`の`formLogin`/`logout`設定値を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにログイン/ログアウト（`/login`等のエンドポイント保護依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-007-017" colspan="4">■ CORS/CSRFの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-007.017</td>
      <td>要求</td>
      <td colspan="2">ブラウザ保護設定への依存関係を、`.java`ソースコードの`http.cors()`/`http.csrf()`を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ CORS/CSRFの依存関係を可視化することで、ブラウザ保護設定を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: CORS/CSRFとは、ブラウザ保護設定への依存を指す<br />・ 範囲: JavaParserを使用して`HttpSecurity`の設定分岐（有効/無効/オプション）を抽出する<br />・ 例: `http.cors().and().csrf().disable()`の場合、CORS/CSRF設定が記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ CORS/CSRFの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-007.017-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（`http.cors()`/`http.csrf()`）を対象にCORS/CSRFを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`HttpSecurity`の設定分岐（有効/無効/オプション）を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにCORS/CSRF（ブラウザ保護設定への依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="upper_request">
    <tr>
      <td id="upper-008" colspan="5">■ ライブラリ依存関係の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-008</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションの外部ライブラリ（Lombok、Jackson等）による依存関係を、ソースコードを解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ コンパイル時や実行時に必要なライブラリを可視化することで、ライブラリのバージョン管理とセキュリティ更新の影響範囲を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: ライブラリ依存関係とは、Lombok、Jacksonなどの外部ライブラリの利用による依存関係を指す<br />・ 範囲: ライブラリ依存（Lombok、Jackson）を含む<br />・ 例: @Getterアノテーションを使用しているクラスは、Lombokへの依存関係が存在する</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-008-001" colspan="4">■ Lombokの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-008.001</td>
      <td>要求</td>
      <td colspan="2">`@Getter`等ボイラープレート削減への依存関係を、`.java`ソースコードのlombok注釈を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ Lombokの依存関係を可視化することで、コンパイル時依存を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: Lombokとは、`@Getter`等ボイラープレート削減への依存を指す<br />・ 範囲: JavaParserを使用して`lombok.*`注釈の有無を記録し、コンパイル依存の注意喚起を行う<br />・ 例: `@Getter`が付与されているクラスは、Lombokへの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ Lombokの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-008.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（lombok注釈）を対象にLombokを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`lombok.*`注釈の有無を記録（コンパイル依存の注意喚起）。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにLombok（`@Getter`等ボイラープレート削減への依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-008-002" colspan="4">■ Jacksonの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-008.002</td>
      <td>要求</td>
      <td colspan="2">JSONシリアライズ/デシリアライズ依存関係を、`.java`ソースコードの`ObjectMapper`/注釈を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ Jacksonの依存関係を可視化することで、JSON処理の実装を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: Jacksonとは、JSONシリアライズ/デシリアライズ依存を指す<br />・ 範囲: JavaParserを使用して`ObjectMapper`利用/`@Json*`注釈/循環参照回避設定などを抽出する<br />・ 例: `@JsonIgnore`が付与されているフィールドは、Jacksonへの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ Jacksonの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-008.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（`ObjectMapper`/注釈）を対象にJacksonを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`ObjectMapper`利用/`@Json*`注釈/循環参照回避設定などを抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにJackson（JSONシリアライズ/デシリアライズ依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="upper_request">
    <tr>
      <td id="upper-009" colspan="5">■ アーキテクチャ依存関係の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-009</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションのアーキテクチャ層（Controller、Service、Repository）の依存関係とレイヤー違反を、ソースコードを解析する際に抽出・検出する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ アーキテクチャ層の依存関係を可視化することで、レイヤー分離の原則を遵守しているかを確認できる<br />・ レイヤー違反を検出することで、アーキテクチャの品質を維持できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: アーキテクチャ依存関係とは、Controller→Service、Service→Repository、Repository→Entityなどの層間の依存関係と、Web特有の依存（パス/パラメータ）、テスト依存を含む<br />・ 範囲: アーキ依存、Web特有、テスト依存を含む<br />・ 例: Controllerが直接Repositoryを呼び出している場合、レイヤー違反として検出される</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-009-001" colspan="4">■ Controller→Serviceの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-009.001</td>
      <td>要求</td>
      <td colspan="2">Controller層からService層への層間の正しい依存関係を、`.java`ソースコードのコンストラクタDI/呼出を解析する際に抽出・確認する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ Controller→Serviceの依存関係を可視化することで、層間の正しい依存を確認できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: Controller→Serviceとは、層間の正しい依存を指す<br />・ 範囲: JavaParserを使用してController内のDIフィールド型がServiceであること/呼び出しを確認する<br />・ 例: ControllerがServiceをDIして呼び出している場合、Controller→Serviceの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ Controller→Serviceの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-009.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（コンストラクタDI/呼出）を対象にController→Serviceを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてController内のDIフィールド型がServiceであること/呼び出しを確認。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにController→Service（層間の正しい依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-009-002" colspan="4">■ Service→Repositoryの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-009.002</td>
      <td>要求</td>
      <td colspan="2">Service層からRepository層への層間の正しい依存関係を、`.java`ソースコードのDI/呼出を解析する際に抽出・確認する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ Service→Repositoryの依存関係を可視化することで、層間の正しい依存を確認できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: Service→Repositoryとは、層間の正しい依存を指す<br />・ 範囲: JavaParserを使用してServiceでRepositoryのDI/メソッド呼び出しを抽出する<br />・ 例: ServiceがRepositoryをDIして呼び出している場合、Service→Repositoryの依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ Service→Repositoryの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-009.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（DI/呼出）を対象にService→Repositoryを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてServiceでRepositoryのDI/メソッド呼び出しを抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにService→Repository（層間の正しい依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-009-003" colspan="4">■ Repository→Entityの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-009.003</td>
      <td>要求</td>
      <td colspan="2">Repository層からEntityへの永続化対象への依存関係を、`.java`ソースコードの型引数/注釈を解析する際に抽出・確認する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ Repository→Entityの依存関係を可視化することで、永続化対象を確認できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: Repository→Entityとは、永続化対象への依存を指す<br />・ 範囲: JavaParserを使用して`JpaRepository&lt;T,ID&gt;`のT型/`@Entity`対応を突合する<br />・ 例: `JpaRepository&lt;User, Long&gt;`の場合、Repository→User（Entity）の依存関係が存在する</td>
    </tr>
    <tr>
      <td colspan="3">■ Repository→Entityの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-009.003-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（型引数/注釈）を対象にRepository→Entityを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`JpaRepository&lt;T,ID&gt;`のT型/`@Entity`対応を突合。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにRepository→Entity（永続化対象への依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-009-004" colspan="4">■ パス/パラメータ依存の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-009.004</td>
      <td>要求</td>
      <td colspan="2">`@PathVariable`/`@RequestParam`などの契約依存関係を、`.java`ソースコードのメソッド注釈/引数注釈を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ パス/パラメータ依存を可視化することで、Web APIの契約を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: パス/パラメータ依存とは、`@PathVariable`/`@RequestParam`などの契約依存を指す<br />・ 範囲: JavaParserを使用して`@GetMapping`の`value`/`path`や引数注釈名を抽出する<br />・ 例: `@GetMapping(&quot;/users/{id}&quot;) public User getUser(@PathVariable Long id)`の場合、パス/パラメータ依存が記録される</td>
    </tr>
    <tr>
      <td colspan="3">■ パス/パラメータ依存の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-009.004-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（メソッド注釈/引数注釈）を対象にパス/パラメータ依存を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いて`@GetMapping`の`value`/`path`や引数注釈名を抽出。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにパス/パラメータ依存（`@PathVariable`/`@RequestParam`などの契約依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-009-005" colspan="4">■ テストスライスの解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-009.005</td>
      <td>要求</td>
      <td colspan="2">`@WebMvcTest`等による限定コンテキスト依存関係を、`.java`ソースコードのテスト注釈を解析する際に抽出・記録する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ テストスライスの依存関係を可視化することで、テストで読み込まれるBean範囲を把握できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: テストスライスとは、`@WebMvcTest`等による限定コンテキスト依存を指す<br />・ 範囲: JavaParserを使用してスライス注釈で読み込まれるBean範囲と依存の違いを記録する<br />・ 例: `@WebMvcTest`の場合、Web層のみが読み込まれ、他の層はモックされる</td>
    </tr>
    <tr>
      <td colspan="3">■ テストスライスの解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-009.005-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、`.java`（テスト注釈）を対象にテストスライスを抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>JavaParserを用いてスライス注釈で読み込まれるBean範囲と依存の違いを記録。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにテストスライス（`@WebMvcTest`等による限定コンテキスト依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="upper_request">
    <tr>
      <td id="upper-010" colspan="5">■ 設計品質指標の解析</td>
    </tr>
    <tr>
      <td rowspan="3">REQ-010</td>
      <td>要求</td>
      <td colspan="3">SpringBootアプリケーションの設計品質指標（循環依存、レイヤー違反等）を、依存関係グラフを解析する際に検出・報告する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="3">・ 循環依存やレイヤー違反を検出することで、設計上の問題を早期に発見できる<br />・ 設計品質指標を可視化することで、コードの保守性を向上させられる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="3">・ 用語: 設計品質指標とは、循環依存（クラス間、パッケージ間）、レイヤー違反などの設計上の問題を指す<br />・ 範囲: 設計指標（循環依存、レイヤー違反）を含む<br />・ 例: クラスAがクラスBに依存し、クラスBがクラスAに依存する場合、循環依存として検出される</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-010-001" colspan="4">■ 循環依存（クラス）の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-010.001</td>
      <td>要求</td>
      <td colspan="2">クラス間の依存が相互循環している状態を、依存関係リスト（Graph構造）を解析する際に検出・報告する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ 循環依存を検出することで、設計上の問題を早期に発見できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 循環依存（クラス）とは、クラス間の閉路依存を指す<br />・ 範囲: 自作解析を使用してクラスノードの有向グラフでサイクル検出・最小分割提案を行う<br />・ 例: クラスAがクラスBに依存し、クラスBがクラスAに依存する場合、循環依存として検出される</td>
    </tr>
    <tr>
      <td colspan="3">■ 循環依存（クラス）の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-010.001-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、依存リスト（FQN→FQN）を対象に循環依存（クラス）を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>自作解析を用いてクラスノードの有向グラフでサイクル検出・最小分割提案。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに循環依存（クラス）（クラス間の閉路依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析（グラフ）での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-010-002" colspan="4">■ 循環依存（パッケージ）の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-010.002</td>
      <td>要求</td>
      <td colspan="2">パッケージ間の依存が相互循環している状態を、依存リスト（FQN→FQN）を解析する際に検出・報告する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ パッケージ間の循環依存を検出することで、パッケージ構造の設計上の問題を発見できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: 循環依存（パッケージ）とは、パッケージ間の閉路依存を指す<br />・ 範囲: jdeps、自作解析を使用してパッケージ名で集約後に閉路検出（Tarjan/Kosaraju等のSCC）を行う<br />・ 例: パッケージAがパッケージBに依存し、パッケージBがパッケージAに依存する場合、循環依存として検出される</td>
    </tr>
    <tr>
      <td colspan="3">■ 循環依存（パッケージ）の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-010.002-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、依存リスト（FQN→FQN）を対象に循環依存（パッケージ）を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>jdeps / 自作解析を用いてパッケージ名で集約後に閉路検出（Tarjan/Kosaraju等のSCC）。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルに循環依存（パッケージ）（パッケージ間の閉路依存）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析（グラフ）での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
  <tbody class="lower_request">
    <tr>
      <td rowspan="10" class="upper_request"></td>
      <td id="lower-010-003" colspan="4">■ レイヤー違反の解析</td>
    </tr>
    <tr>
      <td rowspan="9">REQ-010.003</td>
      <td>要求</td>
      <td colspan="2">Controller→Repository直通などの違反を、依存リスト＋命名/パッケージ規約を解析する際に検出・報告する</td>
    </tr>
    <tr>
      <td>理由</td>
      <td colspan="2">・ レイヤー違反を検出することで、アーキテクチャの品質を維持できる</td>
    </tr>
    <tr>
      <td>説明</td>
      <td colspan="2">・ 用語: レイヤー違反とは、Controller→Repository直通などの違反を指す<br />・ 範囲: 自作ルールエンジンを使用して`controller..`→`repository..`直接エッジを検出し警告する<br />・ 例: Controllerが直接Repositoryを呼び出している場合、レイヤー違反として検出される</td>
    </tr>
    <tr>
      <td colspan="3">■ レイヤー違反の解析仕様</td>
    </tr>
    <tr>
      <td rowspan="5">SPC-010.003-001</td>
      <td>前提</td>
      <td>SpringBootアプリケーションのソースコードが`targetProjectPath`配下に存在し、H2インメモリデータベースとJPAプロファイル`jpa`が初期化済であること。</td>
    </tr>
    <tr>
      <td>入力</td>
      <td>解析オペレータが`targetProjectPath`と`targetPackagePattern`を指定し、依存リスト＋命名/パッケージ規約を対象にレイヤー違反を抽出する。</td>
    </tr>
    <tr>
      <td>処理</td>
      <td>自作ルールエンジンを用いて`controller..`→`repository..` 直接エッジを検出し警告。抽出結果を依存レコードとして整形し、`class_dependencies`テーブルへ登録する。</td>
    </tr>
    <tr>
      <td>出力</td>
      <td>H2上の`class_dependencies`テーブルにレイヤー違反（Controller→Repository直通などの違反）のレコードを記録し、解析結果画面にパッケージごとのサマリを反映する。</td>
    </tr>
    <tr>
      <td>制約</td>
      <td>本仕様は静的解析（ルール）での実行を前提とし、JavaParserが対象ソースを正しくパースできる場合に限定する。</td>
    </tr>
  </tbody>
</table>

<!-- Sidebar -->
<nav class="sidebar-nav">
  <ul class="nav-upper">
    <li class="nav-upper-item">
      <a href="#page_top">▲ ページトップ</a>
    </li>
  </ul>
  <ul class="nav-upper">
    <li class="nav-upper-item">
      <a href="#upper-001">基本型依存関係の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-001-001">継承（extends）の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-002">実装（implements）の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-003">ジェネリクス型参照の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-004">例外型依存の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-005">メソッド呼び出しの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-006">戻り値型依存の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-007">引数型依存の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-008">静的メソッド依存の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-009">コンポジション（保持）の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-010">集合保持の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-001-011">定数参照の解析</a></li>
      </ul>
    </li>
    <li class="nav-upper-item">
      <a href="#upper-002">DI（依存性注入）依存関係の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-002-001">SetterDIの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-002-002">@Bean提供の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-002-003">コンストラクタDIの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-002-004">フィールドDIの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-002-005">コントローラ定義の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-002-006">サービス層定義の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-002-007">リポジトリ層定義の解析</a></li>
      </ul>
    </li>
    <li class="nav-upper-item">
      <a href="#upper-003">永続化層依存関係の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-003-001">JPAリポジトリの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-003-002">JPAエンティティの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-003-003">クエリメソッドの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-003-004">DTOの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-003-005">マッパーの解析</a></li>
      </ul>
    </li>
    <li class="nav-upper-item">
      <a href="#upper-004">設定・構成依存関係の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-004-001">@Value注入の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-004-002">構成プロパティの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-004-003">プロファイル条件の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-004-004">オートコンフィグの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-004-005">ビルド依存の解析</a></li>
      </ul>
    </li>
    <li class="nav-upper-item">
      <a href="#upper-005">外部サービス・イベント依存関係の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-005-001">アプリイベント購読の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-005-002">HTTPクライアントの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-005-003">メッセージングの解析</a></li>
      </ul>
    </li>
    <li class="nav-upper-item">
      <a href="#upper-006">横断的関心事依存関係の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-006-001">トランザクションの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-006-002">横断的関心事の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-006-003">ログ/メトリクスの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-006-004">Bean Validationの解析</a></li>
      </ul>
    </li>
    <li class="nav-upper-item">
      <a href="#upper-007">セキュリティ依存関係の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-007-001">SecurityFilterChain構成の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-002">HttpSecurityルールの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-003">UserDetailsの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-004">UserDetailsServiceの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-005">PasswordEncoderの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-006">AuthenticationManagerの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-007">AuthenticationProviderの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-008">OncePerRequestFilterの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-009">メソッドセキュリティの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-010">ロール/権限の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-011">SecurityContextの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-012">Session管理の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-013">トークン抽出の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-014">署名/検証の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-015">クレーム→権限の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-016">ログイン/ログアウトの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-007-017">CORS/CSRFの解析</a></li>
      </ul>
    </li>
    <li class="nav-upper-item">
      <a href="#upper-008">ライブラリ依存関係の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-008-001">Lombokの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-008-002">Jacksonの解析</a></li>
      </ul>
    </li>
    <li class="nav-upper-item">
      <a href="#upper-009">アーキテクチャ依存関係の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-009-001">Controller→Serviceの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-009-002">Service→Repositoryの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-009-003">Repository→Entityの解析</a></li>
        <li class="nav-lower-item"><a href="#lower-009-004">パス/パラメータ依存の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-009-005">テストスライスの解析</a></li>
      </ul>
    </li>
    <li class="nav-upper-item">
      <a href="#upper-010">設計品質指標の解析</a>
      <ul class="nav-lower">
        <li class="nav-lower-item"><a href="#lower-010-001">循環依存（クラス）の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-010-002">循環依存（パッケージ）の解析</a></li>
        <li class="nav-lower-item"><a href="#lower-010-003">レイヤー違反の解析</a></li>
      </ul>
    </li>
  </ul>
  <ul class="nav-upper">
    <li class="nav-upper-item">
      <a href="#page_top">▲ ページトップ</a>
    </li>
  </ul>
</nav>



</body>
</html>
